#!/bin/bash

# This is a custom implementation of the standard "waitForQualityGate"
# pipeline stage for the cases when we can' use the standard one
#
# Variables taken from environment of the script:
# TOKEN       - token to authenticate at Sonar server
# SONAR_FILE - path to report-task.txt generated by Sonar CLI
#

me=$(basename $0)

function get_sonar_property()
{
    local prop_name=$1
    echo $(grep $prop_name $SONAR_FILE | tail -n1 | sed -e "s/${prop_name}=//g")
}

function check_var_is_set()
{
    eval "x=\$${1}"
    echo "${me}: Required input \$${1}=${x}"
    if [ "$x" == "" ] ; then
        echo "${me}: ${1} required variable is empty or undefined. Exit."
        exit 1
    fi
}

check_var_is_set SONAR_FILE

if [ ! -f $SONAR_FILE ]; then
    echo "${me}: Sonar report ${SONAR_FILE} not found"
    exit 1
fi

task_url=$(get_sonar_property ceTaskUrl)
server_url=$(get_sonar_property serverUrl)

check_var_is_set task_url
check_var_is_set server_url

http_status=$(curl -s -o /dev/null -w '%{http_code}' -u $TOKEN: $task_url)

if [  $http_status -ne 200 ]; then
    echo "Sonar API token has no access rights. Exit."
    exit 1
fi

analysis_id=$(curl -XGET -s -u $TOKEN: $task_url | jq -r .task.analysisId)
timeout=1
wait_time=0
while [ "$analysis_id" == "null" ]; do
    if [ $wait_time -gt 30 ]; then
        echo "Timeout of ${wait_time} seconds exceeded for getting Sonar analysis_id"
        exit 1
    fi
    
    sleep $timeout
    wait_time=$((wait_time + timeout))
    timeout=$((timeout + 1))
    
    analysis_id=$(curl -XGET -s -u $TOKEN: $task_url | jq -r .task.analysisId)
done

check_var_is_set analysis_id

status=$(curl -XGET -s -u $TOKEN: \
            "${server_url}/api/qualitygates/project_status?analysisId=${analysis_id}" | \
            jq -r .projectStatus.status)

if [ "$status" == "ERROR" ]; then
    echo "Qualitygate failed."
    exit 1
fi

echo "Sonar Qualitygate is OK."
exit 0
