/*
 * Generated by genxface.pl - DO NOT EDIT OR COMMIT TO SOURCE CODE CONTROL!
 */
#ifdef __cplusplus
extern "C" {
#endif

void fileprefs_freehashes(void) ;
void fileprefs_set_strict(bool enabled) ;
void fileprefs_free(struct fileprefs *me) ;

/*
 * Log an error, always returning false.
 */
bool fileprefs_log_error(struct fileprefs *me, const char *line, const char *func, const struct conf_loader *cl, const char *type,
                    const char *inval, unsigned read, unsigned total) ;
bool fileprefs_readlist(struct fileprefs *me, struct prefbuilder *pb, struct conf_loader *cl, const char *line) ;

/**
 * Initialize fileprefs; used by lists
 *
 * @param me        Pointer to the structure to initialize
 * @param ops       Pointer to the class object that defines the prefs type
 * @param loadflags Fileprefs load flags
 */
void fileprefs_init(struct fileprefs *me, const struct fileprefops *ops, unsigned loadflags) ;

/**
 * Load a prefs file section. Also used for lists files
 *
 * @param me         Fileprefs object
 * @param cl         Confloader object initialized to load the file
 * @param pb         Prefbuilder object
 * @param okvers     Zero terminated array of valid version numbers for this file
 * @param section    Pointer to a pointer to the current section (initially NULL)
 * @param count      Pointer to an unsigned integer populated with the header count if a header was found or skipped
 *
 * @return FILEPREFS_SECTION_NOT_FOUND Next line is not a fileprefs section header; in this case, the line is unread
 *         FILEPREFS_SECTION_ERROR     Error parsing the header or skipped lines
 *         FILEPREFS_SECTION_LOADED    Found a valid section header and loaded it, ignoring it if it was for the wrong version
 */
enum fileprefs_section_status fileprefs_load_section(struct fileprefs *me, struct conf_loader *cl, struct prefbuilder *pb, const unsigned *okvers,
                       const struct fileprefs_section **section, unsigned *count) ;

/**
 * Load the header of a prefs file. Also used for lists files and other configuration files.
 *
 * @param me     Pointer to a fileorefs object
 * @param cl     Pointer to a confloader object initialized to load the file
 * @param count  Pointer to an unsigned integer to be populated with the file count
 * @param okvers Pointer to a pointer to be populated with a pointer to a zero terminated array of valid version numbers
 *
 * @return true on success
 */
bool fileprefs_load_fileheader(struct fileprefs *me, struct conf_loader *cl, unsigned *count, unsigned **okvers) ;

/* Allocate and construct a new prefs file object, loading the file content using the conf loader */
struct fileprefs * fileprefs_new(struct conf_loader *cl, struct fileprefops *ops, size_t sz, unsigned loadflags) ;

/* XXX: This should go when HardCIDR stops needing it (via devprefs_policy() and netprefs_policy()) */
bool fileprefs_get_policy(const struct fileprefs *me, pref_t *pref, actype_t actype, uint32_t orgid, uint32_t id) ;

#ifdef __cplusplus
}
#endif
