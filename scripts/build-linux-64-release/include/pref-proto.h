/*
 * Generated by genxface.pl - DO NOT EDIT OR COMMIT TO SOURCE CODE CONTROL!
 */
#ifdef __cplusplus
extern "C" {
#endif


/**
 * Set the value of the global org id; the global org provides base preferences inheritted by parent (MSP) and other orgs
 *
 * @param globalorg Global org id
 */
void pref_set_globalorg(uint32_t globalorg) ;

/**
 * Compare a preflist's key to the specified (ltype,id,elementtype) tuple.
 *
 * @note Used to test whether the result of preflist_find is the index of a preflist that's an exact match.
 */
int preflist_cmp_key(const struct preflist *me, ltype_t ltype, uint32_t id, elementtype_t elementtype) ;
bool ltype_matches_elementtype(ltype_t ltype, elementtype_t elementtype) ;

/**
 * Find a list in an array of preflists, returning the matching or closest index
 *
 * @param me/count             Pointer to the array of preflists and the number of preflists in the array
 * @param ltype/id/elementtype The key to look for in the array
 */
unsigned preflist_find(const struct preflist *me, unsigned count, ltype_t ltype, uint32_t id, elementtype_t elementtype) ;
const struct preflist * preflist_get(const struct preflist *me, unsigned count, ltype_t ltype, uint32_t id, elementtype_t elementtype) ;
const struct prefsettinggroup * prefsettinggroup_get(const struct prefsettinggroup *me, unsigned count, settinggroup_idx_t idx, uint32_t id) ;
const struct prefbundle * prefbundle_get(const struct prefbundle *me, unsigned count, actype_t actype, uint32_t id) ;
const struct preforg * preforg_get(const struct preforg *me, unsigned count, uint32_t id) ;

/**
 * Convert a name into one of the element types (added in 2.3)
 */
elementtype_t pref_list_name_to_elementtype(const char *name) ;

/**
 * Convert an element type back to a name (added in 2.4)
 */
const char * pref_list_elementtype_to_name(elementtype_t elementtype) ;
uint32_t pref_get_globalorg(void) ;
void pref_init_byidentity(pref_t *me, const struct prefblock *blk, const struct prefblock *pblk, const struct prefblock *gblk,
                     unsigned idx) ;
void pref_init_bybundle(pref_t *me, const struct prefblock *blk, const struct prefblock *pblk, const struct prefblock *gblk,
                   uint32_t orgid, unsigned idx) ;
void pref_fini(pref_t *me) ;
const char * pref_bundleflags_to_str(pref_bundleflags_t flags) ;
const char * pref_orgflags_to_str(pref_orgflags_t flags) ;

/*
 * Create a prefblock with 'n' identities, each pointing to their own bundle and org.
 * This is used by dnscache to manage default interface prefs.
 */
struct prefblock * prefblock_new_empty(unsigned n) ;
void prefblock_free(struct prefblock *me) ;

/*
 * If the pref's org wants newly seen domains to be proxied, test whether domain is newly seen.
 */
bool pref_proxy_newly_seen_domain(pref_t *me, pref_categories_t *categories, const uint8_t *name, struct xray *x) ;

/* find a domain in a pref_t */
bool pref_domainlist_match(const pref_t *me, pref_categories_t *match, ltype_t ltype, const uint8_t *name,
                      enum domainlist_match matchtype, struct xray *x) ;

/**
 * Find an application domain in a pref_t (a domain match against url lists)
 *
 * @param me             Prefs to search in; all application preflists hanging off me will be searched
 * @param match          NULL or categories matched; matched category bits are added to any bits already set
 * @param ltype          The list type
 * @param name           DNS (domain) name to search for
 * @param find           Categories to find
 * @param categorization The dynamic categorization
 * @param conf           Current confset, which includes the application-lists
 * @param x              NULL or pointer to an X-ray object used to track diagnostics
 *
 * @return the appid or 0 if not found
 */
uint32_t pref_applicationlist_domain_match(pref_t *me, pref_categories_t *match, ltype_t ltype, const uint8_t *name,
                                  pref_categories_t *find, const struct categorization *categorization,
                                  const struct confset *conf, struct xray *x) ;

/**
 * Find an application domain block/allow proxy in a pref_t (a domain match against url lists)
 *
 * @param me             Prefs to search in; all application preflists hanging off me will be searched
 * @param name           DNS (domain) name to search for
 * @param ltype          The list type
 * @param categorization The dynamic categorization
 * @param conf           Current confset, which includes the application-lists
 * @param x              NULL or pointer to an X-ray object used to track diagnostics
 *
 * @return the appid or 0 if not found
 *
 * @note If a match is found, the resolver will answer the originating client with the proxy address
 *       (url-proxy.conf.opendns.com or url-proxy-https.conf.opendns.com).
 */
uint32_t pref_applicationlist_proxy(pref_t *me, const uint8_t *name, ltype_t ltype, const struct categorization *categorization,
                           const struct confset *conf, struct xray *x) ;

/* find an application url in a pref_t, return the appid */
uint32_t pref_applicationlist_url_match(pref_t *me, const struct application *app, ltype_t ltype, const char *url, size_t ulen, pref_categories_t *match) ;

/*-
 * Returns comma seperated list of application ids in a pref
 *
 * @param me           Pointer to the pref_t to match in
 * @param ltype        List type (e.g. AT_LIST_APPBLOCK or AT_LIST_APPNODECRYP)T
 * @param app_list_str app list is copied to this char array
 * @param max_buf_len  size of char array buffer
 *
 * @return             return true if successful, false otherwise
 */
bool pref_get_app_list_str(pref_t *me, ltype_t ltype, char *app_list_str, int max_buf_len) ;

/*-
 * Find application id in pref_t application list
 *
 * @param me         Pointer to the pref_t to match in
 * @param ltype      List type (e.g. AT_LIST_APPBLOCK or AT_LIST_APPALLOW)
 * @param url_appid  Application ID (of incoming request)
 * @param match      Pointer to pref categories. If not NULL, found category bits will be ORed in to categories
 *
 * @return           return true in the case of match, false otherwise
 */
bool pref_applicationlist_appid_match(pref_t *me, ltype_t ltype, const uint32_t url_appid, pref_categories_t *match) ;

/*-
 * Find a url destination list match in a pref_t
 *
 * @param me         Pointer to the pref_t to match in
 * @param categories Pointer to pref categories. If not NULL, found category bits will be ORed in to categories
 * @param ltype      List type (e.g. AT_LIST_DESTBLOCK or AT_LIST_DESTALLOW)
 * @param url        The url being matched
 * @param length     The length of the url
 * @param x          XRAY information. May be NULL.
 *
 * @return           the number of preflists matched
 */
bool pref_urllist_match(const pref_t *me, pref_categories_t *categories, ltype_t ltype, const char *url, unsigned length, struct xray *x) ;
bool pref_cidrlist_match(const pref_t *me, pref_categories_t *categories, ltype_t ltype, const struct netaddr *addr) ;
struct cidrlist * cidrlist_new_from_pref(const pref_t *me, ltype_t ltype) ;
size_t preflist_buf_size(const struct preflist *preflist) ;
const char * preflist_to_buf(const struct preflist *preflist, char *buf, size_t sz, size_t *len_out) ;
void preflist_refcount_dec(struct preflist *preflist) ;
const char * pref_sorted_list(const pref_t *pref, ltype_t ltype) ;
const struct preflist * prefblock_list(const struct prefblock *me, ltype_t ltype, uint32_t id, elementtype_t elementtype) ;
const struct prefsettinggroup * prefblock_settinggroup(const struct prefblock *me, settinggroup_idx_t idx, uint32_t id) ;
void pref_cook(pref_t *me) ;

/* Combines cooked prefs flags & categories with listener address and country-code/region configuration */
void pref_cook_with_overloads(pref_t *me, const pref_t *listener_pref, pref_orgflags_t listener_overridable_orgflags,
                         pref_bundleflags_t listener_overridable_bundleflags,
                         const pref_categories_t *listener_overridable_categories, const char country_code[3],
                         uint32_t country_region, const struct confset *conf) ;
const struct prefbundle * prefblock_bundle(const struct prefblock *me, actype_t actype, uint32_t id) ;
const struct preforg * prefblock_org(const struct prefblock *me, uint32_t id) ;
unsigned prefblock_count_total(const struct prefblock *me) ;
pref_categories_t * pref_unmasked(const pref_t *me, pref_categories_t *unmasked) ;

#ifdef __cplusplus
}
#endif
