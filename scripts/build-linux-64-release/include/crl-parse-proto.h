/*
 * Generated by genxface.pl - DO NOT EDIT OR COMMIT TO SOURCE CODE CONTROL!
 */
#ifdef __cplusplus
extern "C" {
#endif

const char * crl_type_to_str(uint32_t type) ;

/**
 * Initialize the common rules language parser
 *
 * @param initial_count     Initial number of values allocated for the value stack (default 8)
 * @param maximum_increment Number of values allocated will double until this value is reached (default 4096)
 */
void crl_parse_initialize(unsigned initial_count, unsigned maximum_increment, cJSON *json_builtins_object) ;

/* Return any memory allocated by the current thread
 */
void crl_parse_finalize_thread(void) ;

/* Pop a value and all the values that follow it off the value stack, effectively freeing them
 */
void crl_value_pop(unsigned idx) ;

// Given that the current character is alphabetic, find the first non-identifier after it, populating the value structure

char * crl_peek_identifier(struct crl_source *source, struct crl_value *value) ;
unsigned crl_parse_identifier(struct crl_source *source) ;
unsigned crl_parse_json(struct crl_source *source, const char *after) ;

/**
 * Parse a comma separated list of attributes. Attribute values may be CRL expressions.
 *
 * @param Object defining the text to parse
 *
 * @return Index in the parse stack of the parsed attributes or CRL_ERROR on error.
 *
 * @note The attribute value's count is the number of key/value pairs which follow it.
 */
unsigned crl_parse_attributes(struct crl_source *source) ;
unsigned crl_parse_elementary_expr(struct crl_source *source, const char *after) ;
unsigned crl_parse_monadic_expr(struct crl_source *source, const char *after) ;

// Currently, expressions are grouped right to left. Left to right is tricky.

unsigned crl_parse_additive_expr(struct crl_source *source, const char *after) ;

// Currently, expressions are grouped right to left. Left to right is tricky.

unsigned crl_parse_dyadic_expr(struct crl_source *source, const char *after) ;

/**
 * Parse a CRL conjunction.
 *
 * @return Index of the the expression on the stack or CRL_ERROR on error.
 *
 * @note Conjunctive expressions are grouped right to left but executed left to right.
 */
unsigned crl_parse_conjunction(struct crl_source *source, const char *after) ;

/**
 * Parse a CRL expression.
 *
 * @param source CRL source code
 * @param after  NULL at the beginning of the expression or the last element parsed (used in diagnostics)
 *
 * @return Index of the the expression on the stack or CRL_ERROR on error.
 *
 * @note Disjunctive expressions are grouped right to left but executed left to right.
 */
unsigned crl_parse_expression(struct crl_source *source, const char *after) ;

/**
 * Duplicate a parsed CRL value
 *
 * @param idx         The index of the value on the parsed value stack
 * @param description What the value is (used in error messages)
 *
 * @return The value on success, NULL if out of memory
 *
 * @note On failure to duplicate, frees any memory allocated by to the value on the stack (memory leak prevention)
 */
struct crl_value * crl_value_dup(unsigned idx, const char *description) ;

#ifdef __cplusplus
}
#endif
