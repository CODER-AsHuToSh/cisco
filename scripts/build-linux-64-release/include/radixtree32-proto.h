/*
 * Generated by genxface.pl - DO NOT EDIT OR COMMIT TO SOURCE CODE CONTROL!
 */
#ifdef __cplusplus
extern "C" {
#endif

void radixtree32_delete(struct radixtree32 *me) ;
struct radixtree32 * radixtree32_new(void) ;

/*-
 * Inserting a struct cidr_ipv4 B into a tree rooted at a node N:
 *   While a non-leaf child of N contains B, set N to that child.
 *   (Now we're at a node N that contains B,
 *     and B won't be inserted into a subtree of N,
 *     because no non-leaf child of N contains B.)
 *   If B matches N,
 *     install B as N's value and return.
 *   If N's child field for B is empty,
 *     install B in it and return.
 *   If N's leaf field for B is not empty,
 *     create a new node N' whose struct cidr_ipv4 is the longest one containing
 *     both B and the leaf.  Insert B and the leaf into the
 *     appropriate fields, set N's child field for B to N', and clear
 *     N's leaf field.
 *   If N's child field for B is not empty,
 *     create a new node N' whose struct cidr_ipv4 is the longest one containing
 *     both B and the child.  Insert B and the child into the
 *     appropriate fields, and set N's child field for B to N'.
 */
bool radixtree32_put(struct radixtree32 *me, struct cidr_ipv4 *cidr) ;
struct cidr_ipv4 * radixtree32_get(struct radixtree32 *me, struct in_addr addr) ;
void radixtree32_walk(struct radixtree32 *me, void (*callback)(struct cidr_ipv4 *cidr)) ;

#ifdef __cplusplus
}
#endif
