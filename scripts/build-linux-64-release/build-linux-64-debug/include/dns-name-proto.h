/*
 * Generated by genxface.pl - DO NOT EDIT OR COMMIT TO SOURCE CODE CONTROL!
 */
#ifdef __cplusplus
extern "C" {
#endif

int dns_name_cmp(const uint8_t *name1, const uint8_t *name2) ;

/**
 * @return true if name1 equals name2, using a fast case flattened but non-canonical comparison
 */
bool dns_name_equal(const uint8_t *dn1, const uint8_t *dn2) ;
int dns_name_canoncmp(const uint8_t *name0, const uint8_t *name1) ;
bool dns_name_has_prefix(const uint8_t *name, const uint8_t *prefix) ;
uint8_t * dns_name_dup(const uint8_t *name) ;
const uint8_t * dns_name_label(const uint8_t *name, unsigned labels_to_skip) ;
unsigned dns_name_len(const uint8_t *name) ;
int dns_name_to_lower(uint8_t *dst, const uint8_t *name) ;

/* Maps "\1x\7opendns\3com\0" to "\0com\3opendns\7x\1" */
void dns_name_prefixtreekey(uint8_t *dst, const uint8_t *name, int len) ;

/*-
 * Maps "\0com\3opendns\7x\1" to "x.opendns.com"
 * Maps "\0" to ""
 */
const char * prefixtreekey_txt(const uint8_t *key, int len) ;

/**
 * Prepend a numeric label to a DNS name if the number is non-zero
 *
 * @return The original name if number is 0, the buffer containing the prefixed name, or NULL on buffer overflow.
 */
const uint8_t * dns_name_prefix_unsigned(const uint8_t *name, unsigned number, uint8_t buffer[DNS_MAXLEN_NAME]) ;

/**
 * Convert a DNS name to a string, returning the buffer pointer or NULL if the DNS name is invalid.
 *
 * @param len_out If not NULL, points to a size_t set to the length of the string representation of name excluding '\0'
 */
char * dns_name_to_buf(const uint8_t *name, char *buf, size_t size, size_t *len_out, unsigned flags) ;
const char * dns_name_to_str1(const uint8_t *name) ;
const char * dns_name_to_str2(const uint8_t *name) ;
const char * dns_name_sscan_len(const char *str, const char *delim, uint8_t *name, unsigned *name_len) ;

/*
 * Returns a pointer into NAME to the Nth subdomain of SUPER, or NULL
 * if NAME is not a subdomain of SUPER.
 */
const uint8_t * dns_name_subdomain(const uint8_t *name, const uint8_t *super, unsigned n) ;
bool dns_name_suffix(const uint8_t *name, const uint8_t *suffix) ;

/**
 * Add an additional label to a domain name.
 *
 * @param name      Full domain
 * @param ancestor  Ancestor or 'name' to add a label to
 * @return          Subdomain of 'ancestor' with one additional label from 'name'
 *                  added to 'ancestor', or NULL if 'parent' matches 'name'.
 */
const uint8_t * dns_name_ancestor_subdomain(const uint8_t *name, const uint8_t *ancestor) ;

/*-
 * @return offset of suffix 'little' in 'big' or -1 if it isn't a suffix of 'big'
 */
int dns_name_endswith(const uint8_t *big, const uint8_t *little) ;
unsigned dns_label_count(const uint8_t *name, uint8_t *longest) ;
uint32_t dns_name_hash32(const uint8_t *name) ;
uint32_t dns_label_hash32(const uint8_t *label) ;
uint32_t dns_name_fingerprint_bit(const uint8_t *name) ;
uint8_t dns_label_fingerprint_bit7(const uint8_t *label) ;

#ifdef __cplusplus
}
#endif
