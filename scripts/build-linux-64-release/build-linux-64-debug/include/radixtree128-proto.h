/*
 * Generated by genxface.pl - DO NOT EDIT OR COMMIT TO SOURCE CODE CONTROL!
 */
#ifdef __cplusplus
extern "C" {
#endif

void radixtree128_delete(struct radixtree128 *me) ;
struct radixtree128 * radixtree128_new(void) ;

/*-
 * Inserting a struct cidr_ipv6 B into a tree rooted at a node N:
 *   While a non-leaf child of N contains B, set N to that child.
 *   (Now we're at a node N that contains B,
 *     and B won't be inserted into a subtree of N,
 *     because no non-leaf child of N contains B.)
 *   If B matches N,
 *     install B as N's value and return.
 *   If N's child field for B is empty,
 *     install B in it and return.
 *   If N's leaf field for B is not empty,
 *     create a new node N' whose struct cidr_ipv6 is the longest one containing
 *     both B and the leaf.  Insert B and the leaf into the
 *     appropriate fields, set N's child field for B to N', and clear
 *     N's leaf field.
 *   If N's child field for B is not empty,
 *     create a new node N' whose struct cidr_ipv6 is the longest one containing
 *     both B and the child.  Insert B and the child into the
 *     appropriate fields, and set N's child field for B to N'.
 */
bool radixtree128_put(struct radixtree128 *me, struct cidr_ipv6 *cidr) ;
struct cidr_ipv6 * radixtree128_get(struct radixtree128 *me, const struct in6_addr *ip6addr) ;
void radixtree128_walk(struct radixtree128 *me, void (*callback)(struct cidr_ipv6 *cidr)) ;

#ifdef __cplusplus
}
#endif
